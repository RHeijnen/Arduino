
/*
   Web client sketch for IDE v1.0.1 and w5100/w5200
   Uses GET method.
   Posted October 2012 by SurferTim
   Last modified September 15, 2013
*/
#include <OneWire.h>
#include <DallasTemperature.h>
#include <SPI.h>
#include <Ethernet.h>
#include <MFRC522.h>
// Sensor input pin
#define DATA_PIN 3
// How many bits to use for temperature values: 9, 10, 11 or 12
#define SENSOR_RESOLUTION 9
// Index of sensors connected to data pin, default: 0
#define SENSOR_INDEX 0
OneWire oneWire(DATA_PIN);
DallasTemperature sensors(&oneWire);
DeviceAddress sensorDeviceAddress;

#define SS_PIN 8
#define RST_PIN 9
MFRC522 mfrc522(SS_PIN, RST_PIN);  // Create MFRC522 instance.

// this must be unique
byte mac[] = {  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// change to your network settings
IPAddress ip(192,168,0,200);
IPAddress gateway(192, 168, 0, 1);
IPAddress subnet(255, 255, 255, 0);

// change to your server
IPAddress server(145,24,222,188); // Google
char serverName[] = "145.24.222.188";


// change to your server's port
int serverPort = 80;

EthernetClient client;
int totalCount = 0;
char pageAdd[64];
char userID[64];
// set this to the number of milliseconds delay
// this is 30 seconds
#define delayMillis 3000
long tempint;

unsigned long thisMillis = 0;
unsigned long lastMillis = 0;
int emptycounter = 0;
void setup() {
  Serial.begin(9600);
  pinMode(7, OUTPUT);

  // disable SD SPI
  pinMode(4,OUTPUT);
  digitalWrite(4,HIGH);
  // ss off ?
  pinMode(8,OUTPUT);
  digitalWrite(8,HIGH);
  
  SPI.begin();      // Init SPI bus
  mfrc522.PCD_Init(); // Init MFRC522 card
  // Start ethernet
  Serial.println(F("Starting ethernet..."));
  Ethernet.begin(mac, ip, gateway, gateway, subnet);

  // If using dhcp, comment out the line above 
  // and uncomment the next 2 lines plus the Ethernet.maintain call in loop

  // if(!Ethernet.begin(mac)) Serial.println(F("failed"));
  // else Serial.println(F("ok"));

  Serial.println(Ethernet.localIP());

  delay(2000);
  Serial.println(F("Ready"));

   sensors.begin();
   sensors.getAddress(sensorDeviceAddress, 0);
   sensors.setResolution(sensorDeviceAddress, SENSOR_RESOLUTION);
}

void loop()
{

  thisMillis = millis();

  if(thisMillis - lastMillis > delayMillis)
  {
    lastMillis = thisMillis;
  sensors.requestTemperatures();
  float temperatureInCelsius = sensors.getTempCByIndex(SENSOR_INDEX);
  float temperatureInFahrenheit = sensors.getTempFByIndex(SENSOR_INDEX);
 
  Serial.print("Temperature: ");
  Serial.print(temperatureInCelsius, 4);
  Serial.print(" Celsius, ");
  tempint = (long) temperatureInCelsius;
  Serial.println(tempint);

  if ( ! mfrc522.PICC_IsNewCardPresent()) {
    Serial.println("There is no PICC");
    digitalWrite(7, LOW);
    emptycounter++;
    Serial.println(" Current counter : ");
    Serial.println(emptycounter);
    if (emptycounter >= 5){
     //A = workplace ID
     //U = user ID
     //Te = temperatuur
     //B = busy ( 0 = empty - 1 = busy - 2 = reserved )
     //L = licht
     sprintf(pageAdd,"/p/a.php?A=1&U=0&Te=%u&B=1&L=1",tempint);

     // if connection is not able to be established ( server not found, server port blocked, page not found)
    if(!getPage(server,serverPort,pageAdd)) Serial.print(F("Fail "));
    else Serial.println(F("Pass "));
    totalCount++;
    Serial.println(totalCount,DEC); 
      return;
    }
    return;
  }


  // Card found but error
  if ( ! mfrc522.PICC_ReadCardSerial()) {
    //Serial.println("Cannot get UID");
    return;
  }
  
  digitalWrite(7, HIGH);
  unsigned long UID_unsigned;
  UID_unsigned =  mfrc522.uid.uidByte[0] << 24;
  UID_unsigned += mfrc522.uid.uidByte[1] << 16;
  UID_unsigned += mfrc522.uid.uidByte[2] <<  8;
  UID_unsigned += mfrc522.uid.uidByte[3];

  long UID_LONG=(long)UID_unsigned;
      Serial.println("------Connected Card :---------");
      Serial.println(UID_unsigned);
      Serial.println("-------------------------------");
 
  // reset emptycounter
  emptycounter = 0;
      delay(5000);
      unsigned int testuid = 4294947285;
    // Modify next line to load different page
    // or pass values to server  
      //sprintf(pageAdd,"/add_data.php?uid=%u&busy=1&temperature=%u",UID_unsigned,tempint);
        // sprintf(pageAdd,"/add_data.php?ID=1&UID=1&busy=0&temperatuur=%u&licht=1&decibel=91",tempint);
                  sprintf(pageAdd,"/p/a.php?A=1&U=%u&Te=%u&B=1&L=1",testuid,tempint);

    if(!getPage(server,serverPort,pageAdd)) Serial.print(F("Fail "));
    else Serial.print(F("Pass "));
    totalCount++;
    Serial.println(totalCount,DEC);
  }    
}

byte getPage(IPAddress ipBuf,int thisPort, char *page)
{
  int inChar;
  char outBuf[256];

  Serial.print(F("connecting..."));

  if(client.connect(ipBuf,thisPort) == 1)
  {
    Serial.println(F("connected"));
    sprintf(outBuf,"GET %s HTTP/1.0",page);
    client.println(outBuf);
    sprintf(outBuf,"Host: %s",serverName);
    client.println(outBuf);
    client.println(F("Connection: close\r\n"));
  } 
  else
  {
    Serial.println(F("failed"));
    return 0;
  }

  // connectLoop controls the hardware fail timeout
  int connectLoop = 0;

  while(client.connected())
  {
    while(client.available())
    {
      inChar = client.read();
      Serial.write(inChar);
      // set connectLoop to zero if a packet arrives
      connectLoop = 0;
    }

    connectLoop++;

    // if more than 10000 milliseconds since the last packet
    if(connectLoop > 10000)
    {
      // then close the connection from this end.
      Serial.println();
      Serial.println(F("Timeout"));
      client.stop();
    }
    // this is a delay for the connectLoop timing
    delay(1);
  }

  Serial.println();

  Serial.println(F("disconnecting."));
  // close client end
  client.stop();

  return 1;
}

